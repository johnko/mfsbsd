#!/bin/sh
# $Id$
# MFSBSD CUSTOM

# PROVIDE: jpfconf
# BEFORE:  pf
# REQUIRE: FILESYSTEMS netif
# KEYWORD: nojail

. /etc/rc.subr

name="jpfconf"
start_cmd="jpfconf_start"
stop_cmd=":"


jpfconf_start()
{
	umask 077
	/usr/bin/install -d -m 700	/server/pf > /dev/null 2>&1
	/bin/chmod -R go-rwx /server/pf
	/usr/bin/install -d -m 700	/server/savepf > /dev/null 2>&1
	/bin/chmod -R go-rwx /server/savepf
	/usr/bin/touch /server/savepf/blacklist.table
	/usr/bin/touch /server/savepf/sshbanlist.table
	/usr/bin/touch /server/savepf/whitelist.table
	/usr/bin/touch /server/savepf/weblimit.table
	/usr/bin/touch /server/savepf/maillimit.table
	/usr/bin/touch /server/savepf/outlimit.table
	/usr/bin/touch /server/savepf/loadbalance.anchor
	/usr/bin/touch /server/savepf/jails.anchor
	/usr/bin/touch /server/savepf/ftpout.anchor
	/bin/cat >/server/savepf/ftpout.anchor <<EOF
pass out quick proto tcp from (self) port >10000 to any modulate state
pass in  quick proto tcp from any port 20 to (self) keep state
EOF
	if [ -e /server/pf/pf.conf ]; then
		if [ ! -e /server/savepf/pf.conf.bkp ]; then
			/bin/mv -f /server/pf/pf.conf /server/savepf/pf.conf.bkp
		else
			/bin/rm /server/pf/pf.conf
		fi
	fi

	if [ ! -e /server/pf/pf.conf ]; then
		_tmp=/server/pf/.pf.tmp
		/bin/cat >${_tmp} <<EOF
martians = "{  127.0.0.0/8,  192.168.0.0/16,  172.16.0.0/12, \
               10.0.0.0/8,  169.254.0.0/16,  192.0.2.0/24, \
               0.0.0.0/8,  240.0.0.0/4  }"
										ssh_ports = "{ \
	ssh }"
										mail_ports = "{ \
	smtp, smtps, submission, imap, imaps, pop3, pop3s }"
										web_ports = "{ \
	http, https }"
										db_ports = "{ \
	mysql, postgresql }"
										udp_ports = "{ \
	domain, ntp }"
										dhcp_ports = "{ \
	bootps, bootpc }"
										failover_ports = "{ \
	647, 7911 }"
										tftp_ports = "{ \
	tftp }"
										ftp_ports = "{ \
	ftp, ftp-data, ftps, ftps-data }"
										apple_ports = "{ \
	afpovertcp, rsync, 5900, 5901 }"
										ms_ports = "{ \
	loc-srv, netbios-ns, netbios-dgm, netbios-ssn, microsoft-ds, ldap, ldaps, 3389 }"
										ipsec_ports = "{ \
	isakmp, l2tp, sae-urn }"


ipsec_proto = "{ esp, ah, ipencap }"
icmp_types = "{ echoreq, unreach }"

										tftp_out = "{ \
	10000:60000 }"

client_out = "{ \
	ssh, 2200:2299, \
	smtp, smtps, submission, imap, imaps, pop3, pop3s, \
	http, https, 8000:8999, 44300:44399, \
	mysql, postgresql, \
	domain, ntp, \
	bootps, bootpc, \
	647, 7911, \
	tftp, \
	ftp, ftp-data, ftps, ftps-data, \
	afpovertcp, rsync, 5900, 5901, \
	loc-srv, netbios-ns, netbios-dgm, netbios-ssn, microsoft-ds, ldap, ldaps, 3389, \
	isakmp, l2tp, sae-urn }"


########## OPTIONS ##########
#        1o respond with conn refused = return, otherwise drop
set block-policy drop
#        2o
#        states - maximum number of entries in the memory pool used for state table
#                 entries (filter rules that specify keep state). Default is 10000.
#        frags - maximum number of entries in the memory pool used for packet
#                reassembly (scrub rules). Default is 5000.
#        src-nodes - maximum number of entries in the memory pool used for
#                    tracking source IP addresses (generated by the sticky-address
#                    and source-track options). Default is 10000.
#        tables - maximum number of tables that can be created. The default is 1000.
#        table-entries - the overall limit on how many addresses can be stored in all
#                        tables. The default is 200000. If the system has less than
#                        100MB of physical memory, the default is set to 100000.
set limit { states 100000, frags 5000, src-nodes 100000, \
            table-entries 200000 }
#        3o use less memory by dropping IDLE early
set optimization aggressive
#        4o correctly handle packets
scrub in all fragment reassemble
#        5o Randomize the ID field for all outgoing packets
scrub out all random-id
#        6o If you have MTU problem or something like that
#scrub out all random-id  max-mss 1400
#        7o tables definition
table <blacklist>  persist file "/server/savepf/blacklist.table"
table <sshbanlist> persist file "/server/savepf/sshbanlist.table"
table <whitelist>  persist file "/server/savepf/whitelist.table"
table <weblimit>   persist file "/server/savepf/weblimit.table"
table <maillimit>  persist file "/server/savepf/maillimit.table"
table <outlimit>   persist file "/server/savepf/outlimit.table"


########## TRANSLATION ##########
#        1t outbound FTP
nat-anchor "ftp-proxy/*"
nat-anchor loadbalance
nat-anchor jails

rdr-anchor "ftp-proxy/*"
rdr pass proto tcp from !127.0.0.1 to any port 21 -> 127.0.0.1 port 8021
rdr-anchor loadbalance
rdr-anchor jails
#        2t EXAMPLE Temporarily ban mass downloaders (assuming 401 is not used)
#        rdr proto tcp from <weblimit> to any port \$web_ports -> 127.0.0.1 port 401
#        3t EXAMPLE redirect tcp 444 to 443
#        rdr on lo0 proto tcp from any to any port 444 -> 127.0.0.1 port 443
#        4t EXAMPLE load balance incoming (inet is for ipv4)
#        web_servers = "{ 10.0.0.10, 10.0.0.11, 10.0.0.13 }"
#        rdr proto tcp from any to any port 80 -> \$web_servers round-robin sticky-address
anchor loadbalance
load anchor loadbalance from "/server/savepf/loadbalance.anchor"
#        5t EXAMPLE jail
#        Port redirection (forwarding) from your IP to your jailsâ€™s IPs
#        rdr on re0 proto tcp to port http -> 10.0.0.1 port http
#        rdr on re0 proto tcp to port imap -> 10.0.0.2 port imap
#        If jails need network access (e.g. to download ports) create NAT on your external network interface:
#        nat on re0 from lo1:network to any -> (re0)
anchor jails
load anchor jails from "/server/savepf/jails.anchor"

anchor ftpout

########## FILTER ##########
#        1f block default
block log (user) all
#        Problematic with multi interface
#        block in log quick from no-route to any
#        block in log quick from urpf-failed to any
#        allow localhost to localhost
pass on lo0 from (self) to (self)
EOF
		_dif=`/sbin/ifconfig -l | /usr/bin/sed -E -e 's/lo0//g' -e 's/enc[0-9]+//g' -e 's/ipfw[0-9]+//g' -e 's/pflog[0-9]+//g' -e 's/plip[0-9]+//g'`
		for i in $_dif; do
			########## LOOPED PER INTERFACE except lo0 ##########
			/bin/cat >>${_tmp} <<EOF
pass quick on ${i} proto pfsync keep state (no-sync)
pass on ${i} proto carp keep state
#        2f silently drop broadcasts (cable modem noise) except allow DHCP
pass      quick on ${i} inet proto { tcp, udp } from any port \$dhcp_ports to any port \$dhcp_ports keep state
pass      quick on ${i} inet proto { tcp, udp } from any to any port \$failover_ports keep state
pass  out quick on ${i} inet proto { tcp, udp } from any port \$failover_ports to any modulate state
block in        on ${i} from any to 255.255.255.255
#        3f block sshbanlist
pass in   quick on ${i} from <whitelist> to (self) keep state
pass out  quick on ${i} from (self) to <whitelist> modulate state
block     quick on ${i} from <blacklist>
block log quick on ${i} proto { tcp, udp } from <sshbanlist> to (self) port \$ssh_ports
#        4f allow echo
pass on ${i} inet proto icmp all icmp-type \$icmp_types keep state
#        5f allow traceroute
#        allow out the default range for traceroute(8):
#        "base+nhops*nqueries-1" (33434+64*3-1)
pass out on ${i} proto udp from (self) to any port 33433 >< 33626 keep state
#        6f allow outgoing packets that have our address as source,
#        others are either spoofed or something is misconfigured (NAT disabled,
#        for instance), we want to be nice and do not send out garbage
pass out on ${i} proto { tcp, udp } from (self) to any port \$client_out modulate state
#        7f allow tftp out on 10000:60000
pass out on ${i} proto udp from (self) port \$tftp_out to any modulate state
pass out on ${i} proto udp from (self) to ($i:network)

########## PUNISH BAD BOYS ##########
#        1p punish weblimit
pass in  quick on ${i} proto { tcp, udp } from <weblimit>  to (self) port \$web_ports keep state \
	( max-src-conn 5, max-src-conn-rate 5/2 )
#        2p punish maillimit
pass in  quick on ${i} proto { tcp, udp } from <maillimit> to (self) port \$mail_ports keep state \
	( max-src-conn 5, max-src-conn-rate 5/2 )
#        3p punish outlimit
pass out quick on ${i}                    from (self) to <outlimit> modulate state \
	( max-src-conn 5, max-src-conn-rate 5/2 )


########## RATE LIMIT ##########
#        1r rate limit 15 connections, at 15 new per 2 seconds
pass out on ${i} proto { tcp, udp } from (self) port \$ssh_ports to any modulate state
pass in  on ${i} proto { tcp, udp } from any to (self) port \$ssh_ports keep state \
	( max-src-conn 15, max-src-conn-rate 15/2, \
	overload <sshbanlist> )
#        2r rate limit 1000 connections, at 1000 new per 1 seconds
#        some browsers open parallel connections
#        if we don't flush, this should silently slow them down
pass out on ${i} proto { tcp, udp } from (self) port \$web_ports to any modulate state
pass in  on ${i} proto { tcp, udp } from any to (self) port \$web_ports keep state \
	( max-src-conn 1000, max-src-conn-rate 1000/1, \
	overload <weblimit> )
#        3r rate limit 1000 connections, at 1000 new per 1 seconds
#        if we don't flush, this should silently slow them down
pass out on ${i} proto { tcp, udp } from (self) port \$mail_ports to any modulate state
pass in  on ${i} proto { tcp, udp } from any to (self) port \$mail_ports keep state \
	( max-src-conn 1000, max-src-conn-rate 1000/1, \
	overload <maillimit> )
#        4r
pass out on ${i} proto { tcp, udp } from (self) port \$db_ports to any modulate state
pass in  on ${i} proto { tcp, udp } from any to (self) port \$db_ports keep state \
	( max-src-conn 1000, max-src-conn-rate 1000/1 )
#        5r
pass out on ${i} proto { tcp, udp } from (self) port \$tftp_ports to any modulate state
pass in  on ${i} proto { tcp, udp } from any to (self) port \$tftp_ports keep state \
	( max-src-conn 1000, max-src-conn-rate 1000/1 )
#        6r
pass out on ${i} proto { tcp, udp } from (self) port \$ftp_ports to any modulate state
pass in  on ${i} proto { tcp, udp } from any to (self) port \$ftp_ports keep state \
	( max-src-conn 1000, max-src-conn-rate 1000/1 )
#        7r
pass out on ${i} proto { tcp, udp } from (self) port \$apple_ports to any modulate state
pass in  on ${i} proto { tcp, udp } from any to (self) port \$apple_ports keep state \
	( max-src-conn 1000, max-src-conn-rate 1000/1 )
#        8r
pass out on ${i} proto { tcp, udp } from (self) port \$ms_ports to any modulate state
pass in  on ${i} proto { tcp, udp } from any to (self) port \$ms_ports keep state \
	( max-src-conn 1000, max-src-conn-rate 1000/1 )
#        9r rate limit udp, can't use overload, only max-src-states
pass out on ${i} proto { tcp, udp } from (self) port \$udp_ports to any modulate state
pass in  on ${i} proto udp from any to (self) port \$udp_ports keep state \
	( source-track rule, max-src-states 2 )


########## REGULAR RULES ##########
#        1a VPN
pass in quick on ${i} proto \$ipsec_proto from any to (self)
pass in quick on ${i} proto { tcp, udp } from any port \$ipsec_ports to (self) port \$ipsec_ports
pass out quick on ${i} proto \$ipsec_proto from (self) to any
pass out quick on ${i} proto { tcp, udp } from (self) port \$ipsec_ports to any port \$ipsec_ports


EOF
		done
		########## NOT LOOPED ##########
		/bin/cat >>${_tmp} <<EOF
########## ANCHORS ##########
#        special anchor for inbound ftp-proxy and outbound ftp
anchor "ftp-proxy/*"
pass out proto tcp from (self) to any port 21 modulate state
EOF
		/bin/mv ${_tmp} /server/pf/pf.conf
	fi


	if [ -n "$MYNIC" ]; then
		cat >/dev/null <<EOF
#        4f block martians that should not be routed through Internet
#        ONLY UNCOMMENT IF int != int_if
#block drop in quick on \$int from \$martians to any
#block drop out quick on \$int from any to \$martians
tun_if = "gif0"
int = "$MYNIC"
ext_ipaddr = "{ $MYIP4ADDRESS }"
localnet = \$int:network
#        1t nat tunnel
nat on \$tun_if inet from \$localnet to any -> (\$tun_if)
#        2t nat router
#nat on \$int inet from ! (\$int) to any -> (\$int)
#        3t nat load balance
#nat on \$int inet from any to any -> 192.0.2.16/28 source-hash
#        1f VPN
pass in quick on \$tun_if from any to any
pass out quick on \$tun_if from any to any
#        8f allow act as gateway in and out to only some services
pass log inet proto { tcp, udp } from \$localnet to any port \$client_out keep state
########## ANTISPOOF ##########
antispoof for \$int
EOF
	fi

	#/etc/rc.d/pf onerestart
}

load_rc_config $name
run_rc_command "$1"

